Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, 
construct and return the binary tree.

------------------------------------------------------------------------------------------------------------------





class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return getRoot(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }
    TreeNode getRoot(int[] preorder, int prestart, int preend, int[] inorder, int instart, int inend){
        if (prestart > preend) {
            return null;
        }

        int rootval = preorder[prestart];
        int index = -1;

        for (int i = instart; i <= inend; i++) {
            if (inorder[i] == rootval) {
                index = i;
                break;
            }
        }



    // Construct the binary tree. 
        TreeNode root = new TreeNode(rootval);

        int leftsite = index - instart;

        root.left = getRoot(preorder, prestart + 1, prestart + leftsite, inorder, instart, index - 1);
        root.right = getRoot(preorder, prestart + leftsite +1, preend, inorder, index+1, inend);

        return root;
    }
   

}



执行用时：3 ms, 在所有 Java 提交中击败了54.13%的用户
内存消耗：40.7 MB, 在所有 Java 提交中击败了14.09%的用户




